import * as Char from "../../../Data/Char.tfun" ;
import * as Int from "../../../Data/Integer.tfun" ;
import * as List from "../../../Data/List.tfun" ;
import * as Maybe from "../../../Data/Maybe.tfun" ;
import * as String from "../../../Data/String.tfun" ;
import * as Console from "../../../System/IO/Console.tfun" ;
import Location*, combine*, toString as locationToString* from "./Location.tfun" ;

data Token* =
    UpperIdentifier (String) Location
  | LowerIdentifier (String) Location
  | LiteralChar (Char) Location
  | LiteralString (String) Location
  | LiteralInt (Int) Location
  | As Location
  | Comma Location
  | EOS Location
  | ERROR (String) Location
  ;

type Scanner = {
  input: String,
  inputLength: Int,
  offset: Int,
  column: Int,
  line: Int
};

let keywords = [
  ("as", As)
] ;

let fromString* (input: String): Scanner =
  { input: input
  , inputLength: String.length input
  , offset: 0
  , column: 1
  , line: 1
  } ;

let atEnd (scanner: Scanner): Bool =
  scanner.offset >= scanner.inputLength ;

let currentCharacter (scanner: Scanner): Char =
  if (atEnd scanner)
    '\0'
  else
    String.atElse '\0' scanner.offset scanner.input ;

let skipCharacter (scanner: Scanner): Scanner =
  if (atEnd scanner)
    scanner
  else if (currentCharacter scanner == '\n')
    { offset: scanner.offset + 1, column: 1, line: scanner.line + 1 | scanner }
  else
    { offset: scanner.offset + 1, column: scanner.column + 1 | scanner } ;

let nextCharacter (scanner: Scanner): (Scanner * Char) =
  if (atEnd scanner)
    (scanner, '\0')
  else
    ( skipCharacter scanner
    , currentCharacter scanner
    ) ;

let locationAt (scanner: Scanner): Location =
  Point { line: scanner.line, column: scanner.column, offset: scanner.offset } ;
 
let skipWhile (predicate: Char -> Bool) (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
  let rec loop (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
    if (predicate (currentCharacter scanner))
      loop (skipCharacter scanner) scanner
    else
      (scanner, locationAt previous)
  in
  loop scanner previous;

let isWhitespace* (c: Char): Bool =
  let cv = Char.toInt c
  in cv /= 0 && cv <= 32 ;

let fst t =
  match t with
  | (a, _) -> a ;

let snd t =
  match t with
  | (_, b) -> b ;

let skipWhitespace* scanner =
  skipWhile isWhitespace scanner scanner |> fst ;

let matchOnPredicate (scanner: Scanner) (predicate: Char -> Bool) (constructor: String -> (Location -> a)): (Scanner * a) =
  let startLocation = locationAt scanner
  and skipWhileResult = skipCharacter scanner |> skipWhile predicate scanner
  and scannerp = skipWhileResult |> fst
  and endLocation = skipWhileResult |> snd
  in
    ( scannerp
    , constructor (String.slice scanner.offset scannerp.offset scanner.input) (combine startLocation endLocation)
    ) ;

let matchCharacter char scanner =
  let c = currentCharacter scanner
  in
    if (c == char)
      skipCharacter scanner |> Just
    else
      Nothing ;

let matchLiteralChar scanner =
  let startLocation = locationAt scanner
  and scannerp = skipCharacter scanner
  and matchClosingQuote c scannerp =
    match matchCharacter '\'' scannerp with
    | Nothing -> (scannerp, ERROR "Unterminated char literal" startLocation)
    | Just scannerp2 -> (scannerp2, LiteralChar c (combine startLocation (locationAt scannerp)))
  in
    match nextCharacter scannerp with
    | (scannerp2, '\0') -> (scannerp2, ERROR "Unterminated char literal" startLocation)
    | (scannerp2, '\\') ->
      let scannerp3 = skipCharacter scannerp2
      and cp = currentCharacter scannerp2
      in
        if (cp == 'n')
          matchClosingQuote '\n' scannerp3
        else if (cp == '\\')
          matchClosingQuote '\\' scannerp3
        else if (cp == '\'')
          matchClosingQuote '\'' scannerp3
        else if (cp == '0')
          matchClosingQuote '\0' scannerp3
        else
          (scannerp3, ERROR "Invalid literal char escape sequence" startLocation)
    | (scannerp2, c) ->
      matchClosingQuote c scannerp2 ;

let rec literalStringLoop (literal: String) (scanner: Scanner): Maybe (Scanner * Location * String) =
  if (atEnd scanner)
    Nothing
  else
    let c = currentCharacter scanner
    and scannerp = skipCharacter scanner
    in
      if (c == '"')
        (scannerp, locationAt scanner, literal) |> Just
      else if (c == '\\')
        let cp = currentCharacter scannerp
        and scannerp2 = skipCharacter scannerp
        in
          if (cp == '"')
            literalStringLoop (literal ++ "\"") scannerp2
          else if (cp == 'n')
            literalStringLoop (literal ++ "\n") scannerp2
          else if (cp == '\\')
            literalStringLoop (literal ++ "\\") scannerp2
          else
            Nothing
      else
        literalStringLoop (literal ++ Char.toString c) scannerp;

let matchLiteralString scanner =
  let startLocation = locationAt scanner
  and scannerp = skipCharacter scanner
  in
    match literalStringLoop "" scannerp with
    | Nothing -> (scannerp , ERROR "Illegal string literal" startLocation)
    | Just (scannerp2, endLocation, literal) -> (scannerp2, LiteralString literal (combine startLocation endLocation)) ;

let next* (scanner: Scanner): (Scanner * Token) =
  let scannerp = skipWhitespace scanner
  in
    if (atEnd scannerp)
      (scanner, EOS (locationAt scannerp))
    else
      let c = currentCharacter scannerp
      in
        if (Char.isUpper c)
          matchOnPredicate scannerp Char.isAlpha UpperIdentifier
        else if (Char.isLower c)
          let matched = matchOnPredicate scannerp Char.isAlpha (\t l = { text: t, location: l })
          and scannerp = matched |> fst
          and identifier = matched |> snd
          in
            List.find (\keyword = (fst keyword) == identifier.text) keywords
              |> Maybe.map (\keyword = (scannerp, (snd keyword) identifier.location))
              |> Maybe.withDefault (scannerp, LowerIdentifier identifier.text identifier.location)
            
        else if (Char.isDigit c)
          matchOnPredicate scannerp Char.isDigit (\t l = LiteralInt (Int.fromStringElse 0 t) l)
        else if (c == '"')
          matchLiteralString scannerp
        else if (c == '\'')
          matchLiteralChar scannerp
        else
          match c with
          | ',' -> (skipCharacter scannerp, Comma (locationAt scannerp))
          | _ -> (skipCharacter scannerp, ERROR (Char.toString c) (locationAt scannerp)) ;

let toString* token =
  match token with
  | UpperIdentifier v l -> "UpperIdentifier " ++ v ++ " " ++ locationToString l
  | LowerIdentifier v l -> "LowerIdentifier " ++ v ++ " " ++ locationToString l
  | LiteralChar v l -> "LiteralChar " ++ Char.toString v ++ " " ++ locationToString l
  | LiteralString v l -> "LiteralString " ++ v ++ " " ++ locationToString l
  | LiteralInt v l -> "LiteralInt " ++ Int.toString v ++ " " ++ locationToString l
  | As l -> "as " ++ locationToString l
  | Comma l -> "',' " ++ locationToString l
  | EOS l -> "EOS " ++ locationToString l
  | ERROR v l -> "ERROR " ++ v ++ " " ++ locationToString l
