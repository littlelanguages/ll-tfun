import * as Char from "../../../Data/Char.tfun" ;
import * as Int from "../../../Data/Integer.tfun" ;
import * as String from "../../../Data/String.tfun" ;
import Location*, combine*, toString as locationToString* from "./Location.tfun" ;

data Token* =
    UpperIdentifier (String) Location
  | LowerIdentifier (String) Location
  | LiteralChar (Char) Location
  | LiteralString (String) Location
  | LiteralInt (Int) Location
  | As Location
  | Comma Location
  | EOS Location
  | ERROR (String) Location
  ;

type Scanner = {
  input: String,
  inputLength: Int,
  offset: Int,
  column: Int,
  line: Int
};

let fromString* (input: String): Scanner =
  { input: input
  , inputLength: String.length input
  , offset: 0
  , column: 1
  , line: 1
  } ;

let atEnd (scanner: Scanner): Bool =
  scanner.offset >= scanner.inputLength ;

let char0 = Char.fromInt 0 ;

let currentCharacter (scanner: Scanner): Char =
  if (atEnd scanner)
    char0
  else
    String.atElse char0 scanner.offset scanner.input ;

let skipCharacter (scanner: Scanner): Scanner =
  if (atEnd scanner)
    scanner
  else if (currentCharacter scanner == '\n')
    { offset: scanner.offset + 1, column: 1, line: scanner.line + 1 | scanner }
  else
    { offset: scanner.offset + 1, column: scanner.column + 1 | scanner } ;

let nextCharacter (scanner: Scanner): (Scanner * Char) =
  if (atEnd scanner)
    (scanner, char0)
  else
    ( skipCharacter scanner
    , currentCharacter scanner
    ) ;

let locationAt (scanner: Scanner): Location =
  Point { line: scanner.line, column: scanner.column, offset: scanner.offset } ;
 
let skipWhile (predicate: Char -> Bool) (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
  let rec loop (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
    if (predicate (currentCharacter scanner))
      loop (skipCharacter scanner) scanner
    else
      (scanner, locationAt previous)
  in
  loop scanner previous;

let isWhitespace* (c: Char): Bool =
  let cv = Char.toInt c
  in cv /= 0 && cv <= 32 ;

let fst t =
  match t with
  | (a, _) -> a ;

let snd t =
  match t with
  | (_, b) -> b ;

let skipWhitespace* scanner =
  skipWhile isWhitespace scanner scanner |> fst ;

let matchOnPredicate (scanner: Scanner) (predicate: Char -> Bool) (constructor: String -> (Location -> Token)): (Scanner * Token) =
  let startLocation = locationAt scanner
  and skipWhileResult = skipCharacter scanner |> skipWhile predicate scanner
  and scannerp = skipWhileResult |> fst
  and endLocation = skipWhileResult |> snd
  in
    ( scannerp
    , constructor (String.slice scanner.offset scannerp.offset scanner.input) (combine startLocation endLocation)
    ) ;

let next* (scanner: Scanner): (Scanner * Token) =
  let scannerp = skipWhitespace scanner
  in
    if (atEnd scannerp)
      (scanner, EOS (locationAt scannerp))
    else
      let c = currentCharacter scannerp
      in
        if (Char.isUpper c)
          matchOnPredicate scannerp Char.isAlpha UpperIdentifier
        else if (Char.isLower c)
          matchOnPredicate scannerp Char.isAlpha LowerIdentifier 
        else if (Char.isDigit c)
          matchOnPredicate scannerp Char.isDigit (\t l = LiteralInt (Int.fromStringElse 0 t) l)
--      else if (c == Char.fromInt 34)
--        matchLiteralString scannerp
        else
          match c with
          | ',' -> (skipCharacter scannerp, Comma (locationAt scannerp))
          | _ -> (skipCharacter scannerp, ERROR (Char.toString c) (locationAt scannerp)) ;

let toString* token =
  match token with
  | UpperIdentifier v l -> "UpperIdentifier " ++ v ++ " " ++ locationToString l
  | LowerIdentifier v l -> "LowerIdentifier " ++ v ++ " " ++ locationToString l
  | LiteralChar v l -> "LiteralChar " ++ Char.toString v ++ " " ++ locationToString l
  | LiteralString v l -> "LiteralString " ++ v ++ " " ++ locationToString l
  | LiteralInt v l -> "LiteralInt " ++ Int.toString v ++ " " ++ locationToString l
  | As l -> "as " ++ locationToString l
  | Comma l -> "',' " ++ locationToString l
  | EOS l -> "EOS " ++ locationToString l
  | ERROR v l -> "ERROR " ++ v ++ " " ++ locationToString l
