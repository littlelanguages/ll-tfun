import * as Char from "../../../Data/Char.tfun" ;
import * as Dict from "../../../Data/Dict.tfun" ;
import * as Int from "../../../Data/Integer.tfun" ;
import * as List from "../../../Data/List.tfun" ;
import * as Maybe from "../../../Data/Maybe.tfun" ;
import * as String from "../../../Data/String.tfun" ;
import * as Console from "../../../System/IO/Console.tfun" ;
import Location*, combine*, toString as locationToString* from "./Location.tfun" ;
import Token*, toString* from "./Token.tfun" ;

type Scanner* = {
  input: String,
  inputLength: Int,
  offset: Int,
  column: Int,
  line: Int,
  token: Token
};

let keywords: Dict.Dict String (Location -> Token) = 
  Dict.fromList 
    [ ("as", As)
    , ("False", TFalse)
    , ("True", TTrue)
    ] ;

let atEnd* (scanner: Scanner): Bool =
  scanner.offset >= scanner.inputLength ;

let currentCharacter (scanner: Scanner): Char =
  if (atEnd scanner)
    '\0'
  else
    String.atElse '\0' scanner.offset scanner.input ;

let skipCharacter (scanner: Scanner): Scanner =
  if (atEnd scanner)
    scanner
  else if (currentCharacter scanner == '\n')
    { offset: scanner.offset + 1, column: 1, line: scanner.line + 1 | scanner }
  else
    { offset: scanner.offset + 1, column: scanner.column + 1 | scanner } ;

let nextCharacter (scanner: Scanner): (Scanner * Char) =
  if (atEnd scanner)
    (scanner, '\0')
  else
    ( skipCharacter scanner
    , currentCharacter scanner
    ) ;

let locationAt (scanner: Scanner): Location =
  Point { line: scanner.line, column: scanner.column, offset: scanner.offset } ;
 
let skipWhile (predicate: Char -> Bool) (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
  let rec loop (scanner: Scanner) (previous: Scanner): (Scanner * Location) =
    if (predicate (currentCharacter scanner))
      loop (skipCharacter scanner) scanner
    else
      (scanner, locationAt previous)
  in
  loop scanner previous;

let isWhitespace* (c: Char): Bool =
  let cv = Char.toInt c
  in cv /= 0 && cv <= 32 ;

let fst (t: (a * b)): a =
  match t with
  | (a, _) -> a ;

let snd (t: (a * b)): b =
  match t with
  | (_, b) -> b ;

let skipWhitespace* scanner =
  skipWhile isWhitespace scanner scanner |> fst ;

let matchOnPredicate (scanner: Scanner) (predicate: Char -> Bool) (constructor: String -> (Location -> a)): (Scanner * a) =
  let startLocation = locationAt scanner
  and skipWhileResult = skipCharacter scanner |> skipWhile predicate scanner
  and scannerp = skipWhileResult |> fst
  and endLocation = skipWhileResult |> snd
  in
    ( scannerp
    , constructor (String.slice scanner.offset scannerp.offset scanner.input) (combine startLocation endLocation)
    ) ;

let matchCharacter char scanner =
  let c = currentCharacter scanner
  in
    if (c == char)
      skipCharacter scanner |> Just
    else
      Nothing ;

let matchLiteralChar (scanner: Scanner): Scanner =
  let startLocation = locationAt scanner
  and scannerp = skipCharacter scanner
  and matchClosingQuote c scannerp =
    match matchCharacter '\'' scannerp with
    | Nothing -> { token: ERROR "Unterminated char literal" startLocation | scannerp }
    | Just scannerp2 -> { token: LiteralChar c (combine startLocation (locationAt scannerp)) | scannerp2 }
  in
    match nextCharacter scannerp with
    | (scannerp2, '\0') -> { token: ERROR "Unterminated char literal" startLocation | scannerp2 }
    | (scannerp2, '\\') ->
      let scannerp3 = skipCharacter scannerp2
      in
        ( match currentCharacter scannerp2 with
          | 'n' -> matchClosingQuote '\n' scannerp3
          | '\\' -> matchClosingQuote '\\' scannerp3
          | '\'' -> matchClosingQuote '\'' scannerp3
          | '0' -> matchClosingQuote '\0' scannerp3
          | _ -> { token: ERROR "Invalid literal char escape sequence" startLocation | scannerp3 }
        )
    | (scannerp2, c) ->
      matchClosingQuote c scannerp2 ;

let rec literalStringLoop (literal: String) (scanner: Scanner): Maybe (Scanner * Location * String) =
  if (atEnd scanner)
    Nothing
  else
    let c = currentCharacter scanner
    and scannerp = skipCharacter scanner
    in
      if (c == '"')
        (scannerp, locationAt scanner, literal) |> Just
      else if (c == '\\')
        let scannerp2 = skipCharacter scannerp
        in
          match currentCharacter scannerp with
          | '"' -> literalStringLoop (literal ++ "\"") scannerp2
          | 'n' -> literalStringLoop (literal ++ "\n") scannerp2
          | '\\' -> literalStringLoop (literal ++ "\\") scannerp2
          | _ -> Nothing
      else
        literalStringLoop (literal ++ Char.toString c) scannerp;

let matchLiteralString scanner =
  let startLocation = locationAt scanner
  and scannerp = skipCharacter scanner
  in
    match literalStringLoop "" scannerp with
    | Nothing -> { token: ERROR "Illegal string literal" startLocation | scannerp }
    | Just (scannerp2, endLocation, literal) -> { token: LiteralString literal (combine startLocation endLocation) | scannerp2 } ;

let matchIdentifier (identifierConstructor: String -> (Location -> Token)) (scanner: Scanner): Scanner =
  let matched = matchOnPredicate scanner Char.isAlpha (\t l = { text: t, location: l })
  and scannerp = matched |> fst
  and identifier = matched |> snd
  in
    match Dict.get identifier.text keywords with
    | Just constructor -> { token: constructor identifier.location | scannerp }
    | Nothing -> { token: identifierConstructor identifier.text identifier.location | scannerp } ;

let next* (scanner: Scanner): Scanner =
  let scannerp = skipWhitespace scanner
  in
    if (atEnd scannerp)
      { token: EOS (locationAt scannerp) | scanner }
    else
      let c = currentCharacter scannerp
      in
        if (Char.isUpper c)
          matchIdentifier UpperIdentifier scannerp
        else if (Char.isLower c)
          matchIdentifier LowerIdentifier scannerp
        else if (Char.isDigit c)
          let mr = matchOnPredicate scannerp Char.isDigit (\t l = LiteralInt (Int.fromStringElse 0 t) l)
          in
            { token: snd mr | fst mr }
        else if (c == '"')
          matchLiteralString scannerp
        else if (c == '\'')
          matchLiteralChar scannerp
        else
          match c with
          | ',' -> { token: Comma (locationAt scannerp) | skipCharacter scannerp }
          | _ -> { token: ERROR (Char.toString c) (locationAt scannerp) | skipCharacter scannerp } ;

let fromString* (input: String): Scanner =
  { input: input
  , inputLength: String.length input
  , offset: 0
  , column: 1
  , line: 1
  , token: EOS (Point { line: 1, column: 1, offset: 0 })
  } |> next
